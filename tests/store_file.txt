$allowedMimeTypes = ['application/pdf', 'image/png', 'image/jpeg'];

if (!in_array($file->getClientMediaType(), $allowedMimeTypes, true)) {
    return $response->withStatus(400)->withJson([
        'error' => '許可されていないファイル形式です'
    ]);
}

// 重複チェック：同じ名前・同じフォルダに未削除のファイルがあるか
$stmt = $pdo->prepare("
    SELECT 1 FROM files
    WHERE folder_id = :folder_id
      AND logical_name = :logical_name
      AND is_deleted = FALSE
    LIMIT 1
");
$stmt->execute([
    ':folder_id' => $folderId,
    ':logical_name' => $logicalName
]);

if ($stmt->fetchColumn()) {
    return $response->withStatus(409)->withJson([
        'error' => '同じ名前のファイルがすでに存在します'
    ]);
}


function resolveFolderId(PDO $pdo, array $pathParts): ?string {
    $parentId = null;

    foreach ($pathParts as $name) {
        $stmt = $pdo->prepare("
            SELECT id FROM folders
            WHERE name = :name AND parent_id IS NOT DISTINCT FROM :parent_id AND is_deleted = FALSE
        ");
        $stmt->execute([':name' => $name, ':parent_id' => $parentId]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$row) {
            return null; // フォルダが存在しない
        }

        $parentId = $row['id'];
    }

    return $parentId;
}
function registerFile(PDO $pdo, string $folderId, string $logicalName, string $mimeType, int $size): array {
    $stmt = $pdo->prepare("
        SELECT MAX(version) FROM files
        WHERE folder_id = :folder_id AND logical_name = :logical_name
    ");
    $stmt->execute([':folder_id' => $folderId, ':logical_name' => $logicalName]);
    $version = (int)$stmt->fetchColumn() + 1;

    $stmt = $pdo->prepare("
        INSERT INTO files (folder_id, logical_name, version, mime_type, size, is_deleted, uploaded_at, updated_at)
        VALUES (:folder_id, :logical_name, :version, :mime_type, :size, FALSE, NOW(), NOW())
        RETURNING id
    ");
    $stmt->execute([
        ':folder_id' => $folderId,
        ':logical_name' => $logicalName,
        ':version' => $version,
        ':mime_type' => $mimeType,
        ':size' => $size
    ]);

    return ['id' => $stmt->fetchColumn(), 'version' => $version];
}

function saveUploadedFile(array $file, string $id, string $storageDir): void {
    $targetPath = rtrim($storageDir, '/') . '/' . $id;
    if (!move_uploaded_file($file['tmp_name'], $targetPath)) {
        throw new RuntimeException("ファイルの保存に失敗しました");
    }
}

use Psr\Http\Message\ResponseInterface as Response;
use Psr\Http\Message\ServerRequestInterface as Request;
use Slim\Factory\AppFactory;

require __DIR__ . '/../vendor/autoload.php';

$app = AppFactory::create();

$app->post('/upload', function (Request $request, Response $response) {
    $pdo = new PDO('pgsql:host=localhost;dbname=yourdb', 'user', 'pass');

    $parsedBody = $request->getParsedBody();
    $uploadedFiles = $request->getUploadedFiles();

    $fullPath = $parsedBody['path'] ?? '';
    $file = $uploadedFiles['file'] ?? null;

    if (!$fullPath || !$file) {
        return $response->withStatus(400)->withJson(['error' => 'path and file are required']);
    }

    $pathParts = array_filter(explode('/', $fullPath));
    $logicalName = array_pop($pathParts);

    try {
        $pdo->beginTransaction();

        $folderId = resolveFolderId($pdo, $pathParts);
        if (!$folderId) {
            throw new RuntimeException("フォルダが存在しません");
        }

        $info = registerFile($pdo, $folderId, $logicalName, $file->getClientMediaType(), $file->getSize());
        saveUploadedFile($file, $info['id'], __DIR__ . '/../storage');

        $pdo->commit();

        $response->getBody()->write(json_encode([
            'id' => $info['id'],
            'version' => $info['version']
        ]));
        return $response->withHeader('Content-Type', 'application/json');
    } catch (Exception $e) {
        $pdo->rollBack();
        return $response->withStatus(500)->withJson(['error' => $e->getMessage()]);
    }
});

$app->run();


